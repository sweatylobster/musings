\documentclass{article}

\title{Making interfaces}
\author{Max de Hoyos}

\begin{document}
\maketitle

Interfaces simplify jobs, but how do you make a good one? 

\begin{enumerate}
	\item You always know what you can do, or can get it easily
	\item Context-sensitive keybindings.
	\item Clear visuals.
	\item Right amount of compression; symbols should be explainable.
\end{enumerate}

$1$'s explained by $2$ and $3$, but $4$'s really a keybinding problem. You have to make some unique symbols. So we have to balance being easy to learn with being easy to use. APIs have to do this too, but have a priority for readability, not necessarily minimizing the number of distinct symbols you have to use and remember. You can write a sentence with letters but you can't think it through easily. But if you have to type a whole complicated sequence Some stuff's really usable but its symbols are cryptic. 

They get you into position with a context-sensitive menu, and give you keybinds to switch contexts. This makes a number of routines available with a simple keybind. We need interfaces for both Conexem navigation and our software routines, like selecting a range of days to bill.

The style of navigation for the two tasks is different. Let's stick with Conexem for a second. Conexem is a tree that constantly needs node to node navigation. What the mind does is determine the path based on the endpoint and current position. This is really inefficient. We usually want the information at the endpoint. The interface would yield a schematized endpoint. We can determine the rationale for the traversal and offer a keybind to get the OOP 

Making an interface requires an architecture. The Elm architecture is popular and simple, and should suffice for our purposes.


\end{document}
