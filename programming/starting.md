# How to think about programming

We always use a screen while programming; this might not always be the case.
But we read symbols that give us an idea of what output to predict.
The output of `print('hi')` should be pretty easy to predict.
But this is exactly the trouble of programming.
We don't know what we're working with, precisely because we believe we're using a language.
But we're not using a language.
We're using a machine.
Why is the distinction meaningful?
Well firstly -- good luck defining language.
I can play a bunch of word games, and know I'm pointing at something essential.
But where does this go?[^1]
However, I do know a machine always works on something to produce an output.
I know, also, that this is a good, workable definition.
But here's the key distinction.
There will, e.g., never be infinitives ("to run", "to print") in programming.
because the nature of a machine is to *do something **to** something*.
What does it mean for a machine to run?
It sounds stupid.
"It obviously means it's on, drawing power, awaiting input, etc."
Now what does it mean for a man to run?
What happens when I ask that question?

Here's something to accentuate the difference.
If I say:
"Is a machine a language?"
I only mean 'language' in a limited sense.
We just saw the infinitive is a potent agonist of the imagination.
What kind of language makes the infinitive a non-citizen?
With a view to programming languages, infinitives take the form of functions.
"To add two numbers, to add two strings, to convert a string to a number..."
But these are basically functions.
You do things to things.
If you haven't cast your school days to oblivion, "direct objects of a transitive verb" might ring a bell.
In programming, the direct objects are arguments, and the function is a transitive infinitive verb.
Same thing -- we have to aim at *that type of thing*.
When I say "to jump" (*please* don't ask how high) -- what happens?
Do you jump to your death?[^2] Do you jump someone? The latter is the only way in which it could be *meant* to a machine.
But enough of this.

But they require typing -- and I don't mean dactylography.
One must define homogenous substances.
Python says: "TypeError: unsupported operand type(s) for +: 'int' and 'str'"
Or, when done the other way 'round: "TypeError: can only concatenate str (not "int") to str"
In Lua: "stdin:1: attempt to add a 'string' with a 'number'"


Now let's ask:
"What sort of machine is language?"
I think more of mental *mechanics* than of machinery.
Now here is the proof that it is meaningful that a machine is not a language;
It is clear that a machine is not a language language is a machine?


Literature is not *possible* for a machine.
These constructions convey nothing to it.
Furthermore, it's impossible, in the sense that it can't produce it by its power.
We have language and number innately.
Now, is language a machine?
If language is a machine, it must not be entirely like what a computer is.
It rather seems to be a machinery.
Just like number, it's both the forge and the forged.
I don't think it's fair to say that thought is always the substance which is being worked upon.
Some of Chomsky's tricks come to mind.
However, on a related note, we could also ask whether a number is a machine.
The word calculus comes to mind, and seems more appropriate in the latter case.
To call language a calculus -- (...)
It must adapt iron according to a routine.
Yes, an LLM can re-produce any number of infinitives.
But let's dig in to the problem a bit more.
What kind of symbol is an infinitive?

This is already something very unlike language, what we're dealing with.
What sort of language would get along without being able to *admit* of an infinitive?
It seems many idioms take advantage of the fact that 
A digital idiom? A voltaic idiom?
Infinitives can't be understood by a machine.
Every verb has a direct object.
To be skilled in anything is to predict the future.
A good developer knows how to write what's needed to get what you say you want.
He's acquainted with the digital idiom.
The skill of development is knowing which symbols will yield the desired output.
Humans get excited about ideas without knowing how to implement them.


To futureproof our argument.
We're obviously using a machine when programming.
This should constrain our reasoning.
Machines function according to physical laws.
Memory management, execution time, etc.
We should also ask, since big O notation comes to mind, whether a number is a machine.
So the zen of debugging is to accept the error as lawful.
"This is always supposed to happen."
We just don't agree with the output.
Bad musicians don't break the laws of physics; they just disagree with the output.
In any case, being a better artist has to do with predicting output, having it in your head beforehand.
You should know what's gonna happen when you run the code.
This is what the practical 

It's a little bit like chemistry.


We might not know the cause might be out of view, 
(Spatial constraints like memory store and retrieval, getting and processing input.)
But hardly any 'programmer' knows assembly language, or how to represent any old thing in ASCII.
We have functions for this sort of thing, because we're developing applications for the machine.
We should really ask what the machine *is*.
RAM, a motherboard, a CPU, an SSD, a GPU...
So what's an operating system?
I don't know, really, but I'm apparently using one.

We're not interested in these spatial constraints as programmers of applications.
That is, if someone is using an API, they're using the machine symbolically.
A symbol means something in a language, or a calculus.
The concept of water is plenty clear.
It's that thing I always forget to drink.
Now how am I aware that water is H2O?
And are these interchangeable?
I'm being funny when I ask someone to pass me some H2O.
Symbols must be read and interpreted.
Anything meant by the symbol 

### Removal but kinda relevant
A fortiori, *a* language, without a saucy air of piquant humor, e.g.
"French is for hacks."
Be that as it may, I still don't know what a language is.
To add insult to injury, I'll ask:
"Qu'est-ce que c'est une langage?"
Or to borrow the partitive genitive, "Qu'est-ce qu'il y a dans le coeur des langages?"
I can play a bunch of word games, and know I'm pointing at something essential.
[^1]But only Wittgenstein makes me feel this goes anywhere.
And still, it's only as a road, and not a definition.
I've hardly read the guy, but he doesn't seem to define language on the first few pages.

##
2023-05-02
[^2] How do characters jump in video games, for example? 
You shift their coordinate system a fixed amount.
They enter a definite relation to the environment.
They go through states.
States imply a system.
By jumping, they just undergo a defined routine of transformations to their configuration, which is seen as an object.
It's a routine that *has* to execute in a specific way.
You might also introduce a fatigue function to prevent your game from being ridiculous.
But this has to be *implemented* in a definite way.
I don't enter a special contract with God, or my particular spacetime, when I jump.
(I don't mean those to be interchangeable, either. God forbid.)
I just jump -- I don't care about how, or where, or with who, or in what way.
I just fucking jump. Or I stand up and then jump.
But I get the idea, the impulse -- I don't even care that I'm in the shower, on a mountainside, or at the edge of a pool.
We get impulses and do them without exhaustively relating to our environment.
There's no doubt of the possibility.
Everything that occurs to us in real life and through language is already implemented.
We only think of "implemented" things.
That is -- you can't think of impossible things.
Everything that's impossible is impossible 'cause you can't do it, or it can't be done.
Most of the time, people say "can't be done" when they only haven't seen it done.
And when they do see it done, they want to know how the magic trick works, instead of accepting they were wrong.
We have a hard time accepting possibility, accepting reality.
We're too ignorant and arrogant to *really* know what's impossible.
It's a better habit to believe that what occurs to your imagination is possible.
And to believe that you simply haven't found the way to do what what you imagine.
Most of the things that you recognize are real are things that you never did imagine were real.
You experienced them in your formative years, and were finally able to take them for granted by the time you were able to speak and point.
So the things that you imagine now are based on this comfort with reality.
The way the mind manages concepts which manipulate futures, control nature and reality
Forget the rules in a video game, for example.
The rules actually give the programmers some peace of mind -- until speedrunners find exploits precisely *through* the rules as they're implemented.
Speedrunners are working according to the laws of the game.
They are precisely in accordance with the machine as it was constructed.
This is why speedrunning is fascinating -- it's vanilla exploitation of the machine's architecture.
It's software parkour.
